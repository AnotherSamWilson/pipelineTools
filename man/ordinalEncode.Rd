% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ordinalEncoding.R
\name{ordinalEncode}
\alias{ordinalEncode}
\title{ordinalEncode}
\usage{
ordinalEncode(
  orderings,
  newLevelHandling = c("fail", "ghost"),
  treatNA = c("newLevel", "ghost", "fail"),
  setNA = "na",
  sep = ".",
  values = c(0, 1)
)
}
\arguments{
\item{orderings}{a named list containing vectors of the ordered levels (from least to greatest) that you wish to encode.
Names must be column names in dt, and elements in the vectors _should_ be valid levels in the data. If any element in the
vectors is not a valid level, the function will throw a warning and treat any unspecified levels according to newLevelHandling.
If you are using treatNA = 'newLevel' then you must specify where in the ordering NA values fall by including NA in each vector.}

\item{newLevelHandling}{How should we treat new levels in the future?
\itemize{
  \item \code{'fail'}   Throws an error.
  \item \code{'ghost'}  Encodes everything as the negative encoding (0, unless specified otherwise in values)
}}

\item{treatNA}{How should NAs be dealt with?
\itemize{
  \item \code{'newLevel'} Creates a new level (setNA). Any future NA values will be set to this. You must specify where in
  the ordering NA values fall if using this option. See orderings documentation.
  \item \code{'ghost'}    Encodes everything as the negative encoding (0, unless specified otherwise in values).
  \item \code{'fail'}     Fails the process if it encounters NA values.
}}

\item{setNA}{The value to set NAs to if treatNA = 'newLevel'}

\item{sep}{The seperator used in creating column names.}

\item{values}{The values to use in the encoding. Default is 0-1, because those are the most commonly used. Other values
may be desired based on activation functions, distance requirements, etc etc.}
}
\value{
Ordinal Encoded Object. This needs to be applied to a dataset, it will not actually return a dataset.
}
\description{
Performs ordinal encoding. I haven't seen this trick anywhere on the internet, but I haven't really looked.
Ordinal encoding is similar to dummy variables, but it 'stacks' the positive encoding at each succissive layer. Therefore,
If you are encoding education, and the options are "High School", "College", "PhD", someone has a PhD, then High School,
College, and PhD will all be 1. If someone went to college, then High School and College will be 1, PhD will be 0. This allows
models to succissively stack the effect of each new level, instead of treating it as a unique thing. This trick was shown to
me by a wise old data mage in Spain by the name of 'Blind Ape'.
}
